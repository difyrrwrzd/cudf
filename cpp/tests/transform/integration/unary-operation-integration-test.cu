/*
 * Copyright (c) 2019, NVIDIA CORPORATION.
 *
 * Copyright 2018-2019 BlazingDB, Inc.
 *     Copyright 2018 Christian Noboa Mardini <christian@blazingdb.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// #include <tests/binaryop/integration/assert-binops.h>
// #include <tests/utilities/cudf_test_fixtures.h>
// #include <cudf/binaryop.hpp>


#include <tests/utilities/cudf_test_fixtures.h>
#include <cudf/transform.hpp>
#include "assert-unary.h"

#include <cctype>

#include <cudf/types.h>

namespace cudf {
namespace test {
namespace transformation {

struct UnaryOperationIntegrationTest : public GdfTest {};

TEST_F(UnaryOperationIntegrationTest, Cube_Vector_FP32_FP32_CUDA) {

using dtype = float;

// c = a*a*a*a
const char* cuda =
R"***(
__device__ inline void    fdsf   (
	float* C,
	float a
)
{
  *C = a*a*a*a;
}
)***";

    auto Cube = [](dtype a) {return a*a*a*a;};

    auto in = cudf::test::column_wrapper<dtype>(500,
        [](gdf_size_type row) {return row % 3;},
        [](gdf_size_type row) {return row % 4;});
    
    gdf_column cpp_output_col;

    CUDF_EXPECT_NO_THROW(cpp_output_col = cudf::transform(*in.get(), cuda, GDF_FLOAT32, false));

    auto cpp_out = cudf::test::column_wrapper<dtype>(cpp_output_col);

    ASSERT_UNARY(cpp_out, in, Cube);
    
    gdf_column_free(&cpp_output_col);
}

TEST_F(UnaryOperationIntegrationTest, Cube_Vector_FP32_FP32) {

using dtype = float;

// c = a*a*a*a
const char* ptx =
R"***(
//
// Generated by NVIDIA NVVM Compiler
//
// Compiler Build ID: CL-24817639
// Cuda compilation tools, release 10.0, V10.0.130
// Based on LLVM 3.4svn
//

.version 6.3
.target sm_70
.address_size 64

	// .globl	_ZN8__main__7add$241Ef
.common .global .align 8 .u64 _ZN08NumbaEnv8__main__7add$241Ef;
.common .global .align 8 .u64 _ZN08NumbaEnv5numba7targets7numbers14int_power_impl12$3clocals$3e13int_power$242Efx;

.visible .func  (.param .b32 func_retval0) _ZN8__main__7add$241Ef(
	.param .b64 _ZN8__main__7add$241Ef_param_0,
	.param .b32 _ZN8__main__7add$241Ef_param_1
)
{
	.reg .f32 	%f<4>;
	.reg .b32 	%r<2>;
	.reg .b64 	%rd<2>;


	ld.param.u64 	%rd1, [_ZN8__main__7add$241Ef_param_0];
	ld.param.f32 	%f1, [_ZN8__main__7add$241Ef_param_1];
	mul.f32 	%f2, %f1, %f1;
	mul.f32 	%f3, %f2, %f2;
	st.f32 	[%rd1], %f3;
	mov.u32 	%r1, 0;
	st.param.b32	[func_retval0+0], %r1;
	ret;
}
)***";

    auto Cube = [](dtype a) {return a*a*a*a;};

    auto in = cudf::test::column_wrapper<dtype>(500,
        [](gdf_size_type row) {return row % 3;},
        [](gdf_size_type row) {return row % 4;});
    
    gdf_column cpp_output_col;

    CUDF_EXPECT_NO_THROW(cpp_output_col = cudf::transform(*in.get(), ptx, GDF_FLOAT32, true));

    auto cpp_out = cudf::test::column_wrapper<dtype>(cpp_output_col);

    ASSERT_UNARY(cpp_out, in, Cube);
    
    gdf_column_free(&cpp_output_col);
}


TEST_F(UnaryOperationIntegrationTest, Cube_Vector_INT32_INT64) {

using dtype = int;

// c = a*a*a*a*a
const char* ptx =
R"***(
//
// Generated by NVIDIA NVVM Compiler
//
// Compiler Build ID: CL-24817639
// Cuda compilation tools, release 10.0, V10.0.130
// Based on LLVM 3.4svn
//

.version 6.3
.target sm_70
.address_size 64

	// .globl	_ZN8__main__7add$241Ei
.common .global .align 8 .u64 _ZN08NumbaEnv8__main__7add$241Ei;
.common .global .align 8 .u64 _ZN08NumbaEnv5numba7targets7numbers14int_power_impl12$3clocals$3e13int_power$242Exx;

.visible .func  (.param .b32 func_retval0) _ZN8__main__7add$241Ei(
	.param .b64 _ZN8__main__7add$241Ei_param_0,
	.param .b32 _ZN8__main__7add$241Ei_param_1
)
{
	.reg .b32 	%r<3>;
	.reg .b64 	%rd<6>;


	ld.param.u64 	%rd1, [_ZN8__main__7add$241Ei_param_0];
	ld.param.u32 	%r1, [_ZN8__main__7add$241Ei_param_1];
	cvt.s64.s32	%rd2, %r1;
	mul.wide.s32 	%rd3, %r1, %r1;
	mul.lo.s64 	%rd4, %rd3, %rd3;
	mul.lo.s64 	%rd5, %rd4, %rd2;
	st.u64 	[%rd1], %rd5;
	mov.u32 	%r2, 0;
	st.param.b32	[func_retval0+0], %r2;
	ret;
}

)***";

    auto Cube = [](dtype a) {return a*a*a*a*a;};

    auto in = cudf::test::column_wrapper<dtype>(500,
        [](gdf_size_type row) {return row % 3;},
        [](gdf_size_type row) {return row % 4;});
  
    gdf_column cpp_output_col;

    CUDF_EXPECT_NO_THROW(cpp_output_col = cudf::transform(*in.get(), ptx, GDF_INT64, true));

    auto cpp_out = cudf::test::column_wrapper<int64_t>(cpp_output_col);

    ASSERT_UNARY(cpp_out, in, Cube);
    
    gdf_column_free(&cpp_output_col);
}

TEST_F(UnaryOperationIntegrationTest, Cube_Vector_BOOL8_BOOL8) {

using dtype = int8_t;

// Capitalize all the lower case letters
// Assuming ASCII, the PTX code is compiled from the following CUDA
/**
__device__ inline void f(
  signed char* output, 
  signed char input
){
	if(input > 96 && input < 123){	
  	*output = input - 32;
  }else{
  	*output = input;    
  }
}
*/
const char* ptx = 
R"***(
.func _Z1fPcc(
        .param .b64 _Z1fPcc_param_0,
        .param .b32 _Z1fPcc_param_1
)
{
        .reg .pred      %p<2>;
        .reg .b16       %rs<6>;
        .reg .b32       %r<3>;
        .reg .b64       %rd<3>;


        ld.param.u64    %rd1, [_Z1fPcc_param_0];
        cvta.to.global.u64      %rd2, %rd1;
        ld.param.s8     %rs1, [_Z1fPcc_param_1];
        add.s16         %rs2, %rs1, -97;
        and.b16         %rs3, %rs2, 255;
        setp.lt.u16     %p1, %rs3, 26;
        cvt.u32.u16     %r1, %rs1;
        add.s32         %r2, %r1, 224;
        cvt.u16.u32     %rs4, %r2;
        selp.b16        %rs5, %rs4, %rs1, %p1;
        st.global.u8    [%rd2], %rs5;
        ret;
}
)***";
    
    auto to_upper = [](dtype a) {return std::toupper(a);};

    auto in = cudf::test::column_wrapper<dtype>(500,
        [](gdf_size_type row) {return 'a' + (row % 26);},
        [](gdf_size_type row) {return true;});
  
    gdf_column cpp_output_col;

    CUDF_EXPECT_NO_THROW(cpp_output_col = cudf::transform(*in.get(), ptx, GDF_INT8, true));

    auto cpp_out = cudf::test::column_wrapper<dtype>(cpp_output_col);

    ASSERT_UNARY(cpp_out, in, to_upper);
    
    gdf_column_free(&cpp_output_col);
}

TEST_F(UnaryOperationIntegrationTest, Cube_Vector_BOOL8_BOOL8_CUDA) {

using dtype = int8_t;

// Capitalize all the lower case letters
// Assuming ASCII
const char* cuda = 
R"***(
__device__ inline void f(
  signed char* output, 
  signed char input
){
	if(input > 96 && input < 123){	
  	*output = input - 32;
  }else{
  	*output = input;    
  }
}
)***";
    
    auto to_upper = [](dtype a) {return std::toupper(a);};

    auto in = cudf::test::column_wrapper<dtype>(500,
        [](gdf_size_type row) {return 'a' + (row % 26);},
        [](gdf_size_type row) {return true;});
  
    gdf_column cpp_output_col;

    CUDF_EXPECT_NO_THROW(cpp_output_col = cudf::transform(*in.get(), cuda, GDF_INT8, false));

    auto cpp_out = cudf::test::column_wrapper<dtype>(cpp_output_col);

    ASSERT_UNARY(cpp_out, in, to_upper);
    
    gdf_column_free(&cpp_output_col);
}

} // namespace transformation
} // namespace test
} // namespace cudf
