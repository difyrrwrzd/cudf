\hypertarget{namespacecudf}{}\section{cudf Namespace Reference}
\label{namespacecudf}\index{cudf@{cudf}}


Invokes an instance of a functor template with the appropriate type determined by a gdf\+\_\+dtype enum value.  


\subsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
using {\bfseries category} = \hyperlink{structcudf_1_1detail_1_1wrapper}{detail\+::wrapper}$<$ gdf\+\_\+category, G\+D\+F\+\_\+\+C\+A\+T\+E\+G\+O\+RY $>$\hypertarget{namespacecudf_a8c6e344a72404039eef838a8cb39295b}{}\label{namespacecudf_a8c6e344a72404039eef838a8cb39295b}

\item 
using {\bfseries timestamp} = \hyperlink{structcudf_1_1detail_1_1wrapper}{detail\+::wrapper}$<$ gdf\+\_\+timestamp, G\+D\+F\+\_\+\+T\+I\+M\+E\+S\+T\+A\+MP $>$\hypertarget{namespacecudf_a6916ffd2fdcad20b769afc3d4130140e}{}\label{namespacecudf_a6916ffd2fdcad20b769afc3d4130140e}

\item 
using {\bfseries date32} = \hyperlink{structcudf_1_1detail_1_1wrapper}{detail\+::wrapper}$<$ gdf\+\_\+date32, G\+D\+F\+\_\+\+D\+A\+T\+E32 $>$\hypertarget{namespacecudf_a788a6ac25db35f51d612644bebd86970}{}\label{namespacecudf_a788a6ac25db35f51d612644bebd86970}

\item 
using {\bfseries date64} = \hyperlink{structcudf_1_1detail_1_1wrapper}{detail\+::wrapper}$<$ gdf\+\_\+date64, G\+D\+F\+\_\+\+D\+A\+T\+E64 $>$\hypertarget{namespacecudf_a5da9e96ba9d677a713403fb3704600ef}{}\label{namespacecudf_a5da9e96ba9d677a713403fb3704600ef}

\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$class functor\+\_\+t , typename... Ts$>$ }\\decltype(auto) C\+U\+D\+A\+\_\+\+H\+O\+S\+T\+\_\+\+D\+E\+V\+I\+C\+E\+\_\+\+C\+A\+L\+L\+A\+B\+LE {\bfseries type\+\_\+dispatcher} (gdf\+\_\+dtype dtype, functor\+\_\+t f, Ts \&\&...args)\hypertarget{namespacecudf_a680bd4460ec432ed855cb77805fa2cdb}{}\label{namespacecudf_a680bd4460ec432ed855cb77805fa2cdb}

\end{DoxyCompactItemize}


\subsection{Detailed Description}
Invokes an instance of a functor template with the appropriate type determined by a gdf\+\_\+dtype enum value. 

This helper function accepts any object with an \char`\"{}operator()\char`\"{} template, e.\+g., a functor. It will invoke an instance of the template by passing in as the template argument an appropriate type determined by the value of the gdf\+\_\+dtype argument.

The template may have 1 or more template parameters, but the first parameter must be the type dispatched from the gdf\+\_\+dtype enum. The remaining template parameters must be able to be automatically deduced.

There is a 1-\/to-\/1 mapping of gdf\+\_\+dtype enum values and dispatched types. However, different gdf\+\_\+dtype values may have the same underlying type. Therefore, in order to provide the 1-\/to-\/1 mapping, a wrapper struct may be dispatched for certain gdf\+\_\+dtype enum values in order to emulate a \char`\"{}strong typedef\char`\"{}.

A strong typedef provides a new, concrete type unlike a normal C++ typedef which is simply a type alias. These \char`\"{}strong typedef\char`\"{} structs simply wrap a single member variable of a fundamental type called \textquotesingle{}value\textquotesingle{}.

The standard arithmetic operators are defined for the wrapper structs and therefore the wrapper struct types can be used as if they were fundamental types.

See \hyperlink{wrapper__types_8hpp}{wrapper\+\_\+types.\+hpp} for more detail.

Example usage with a functor that returns the size of the dispatched type\+:

struct example\+\_\+functor\{ template $<$typename t$>$=\char`\"{}\char`\"{}$>$ int operator()()\{ return sizeof(\+T); \} \};

cudf\+::type\+\_\+dispatcher(\+G\+D\+F\+\_\+\+I\+N\+T8, example\+\_\+functor); // returns 1 cudf\+::type\+\_\+dispatcher(\+G\+D\+F\+\_\+\+I\+N\+T64, example\+\_\+functor); // returns 8

Example usage of a functor for checking if element \char`\"{}i\char`\"{} in column \char`\"{}lhs\char`\"{} is equal to element \char`\"{}j\char`\"{} in column \char`\"{}rhs\char`\"{}\+:

struct elements\+\_\+are\+\_\+equal\{ template $<$typename columntype$>$=\char`\"{}\char`\"{}$>$ bool operator()(void const $\ast$ lhs, int i, void const $\ast$ rhs, int j) \{ // Cast the void$\ast$ data buffer to the dispatched type and retrieve elements // \char`\"{}i\char`\"{} and \char`\"{}j\char`\"{} from the respective columns Column\+Type const i\+\_\+elem = static\+\_\+cast$<$\+Column\+Type const$\ast$$>$(lhs)\mbox{[}i\mbox{]}; Column\+Type const j\+\_\+elem = static\+\_\+cast$<$\+Column\+Type const$\ast$$>$(rhs)\mbox{[}j\mbox{]};

// operator== is defined for wrapper structs such that it performs the // operator== on the underlying values. Therefore, the wrapper structs // can be used as if they were fundamental arithmetic types return i\+\_\+elem == j\+\_\+elem; \} \};

The return type for all template instantiations of the functor\textquotesingle{}s \char`\"{}operator()\char`\"{} lambda must be the same, else there will be a compiler error as you would be trying to return different types from the same function.

dtype The gdf\+\_\+dtype enum that determines which type will be dispatched  f The functor with a templated \char`\"{}operator()\char`\"{} that will be invoked with the dispatched type  args A parameter-\/pack (i.\+e., arbitrary number of arguments) that will be perfectly-\/forwarded as the arguments of the functor\textquotesingle{}s \char`\"{}operator()\char`\"{}.

Whatever is returned by the functor\textquotesingle{}s \char`\"{}operator()\char`\"{}. 